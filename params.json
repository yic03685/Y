{"name":"Y","tagline":"","body":"# Y\r\n\r\n## What is Y?\r\nY is a lightweight library implementing the [flux pattern](https://facebook.github.io/flux/docs/overview.html) with [Rx.js](https://github.com/Reactive-Extensions/RxJS), providing easy-to-use APIs based on observables. You can build models with Y for partial or entire app.\r\nY targets creating models (M in the MVC terminology) for your app so it is independent to whichever view system (V) your app is using.\r\n\r\n## Why Y?\r\nWhile there are many libraries that implement the flux pattern, Y chooses a more restricted way to manage states and dependencies with observables. It helps you make your model easier to manage and scale. For Rx.js users, building the models with Rx only could be tricky sometimes. Y saves you from dealing with things like caching and syntax.\r\n\r\n## Install\r\n```\r\nbower install y-js\r\n```\r\nIn the beta version, the library would expose a global variable called `y`. In the stable version, it would be served in either amd or commonjs format.\r\n\r\n## How does it work?\r\nThe smallest unit in Y is a property. Model is a collection of properties while the goal of model is only for providing properties a meaningful place to sit it.\r\nIn Y, there are two types of properties **State Property** and **Computed Property**\r\n\r\n### State Property\r\nState properties are properties which do not have any dependencies. In Rx's terminology, it serves as both an observer and an observable.\r\nUsusally it has some initial value that can be changed by some user's action. The initial value can be any javascript primitive or an array.\r\nFor example, a User model which has two properties \"firstName\" and \"lastName\" would look like this:\r\n```\r\ny.createModel({\r\n  name: \"User\", // \"name\" is a reserved property for specifying model name\r\n  firstName: \"John\",\r\n  lastName: \"Doe\"\r\n});\r\n```\r\n### Computed Property\r\nComputed properties are properties who can be derived from other properties (whether they are states or other computed properties.) It is similar to observable in Rx.\r\nFor example, a property called \"fullName\" which can be derived by \"firstName\" and \"lastName\" would look like this:\r\n```\r\ny.createModel({\r\n  name: \"User\", // \"name\" is a reserved property for specifying model name\r\n  firstName: \"John\",\r\n  lastName: \"Doe\",\r\n  fullName: function(first, last) {\r\n    return `{first} {last}`;\r\n  }.require(\"firstName\", \"lastName\")\r\n});\r\n```\r\nComputed properties can also depend on properties from other models. If you have another model called \"Config\" and you do not want to show the last name in the full name if it is configured to be private.\r\n```\r\ny.createModel({\r\n  name: \"Config\", // \"name\" is a reserved property for specifying model name\r\n  privacy: \"private\"\r\n});\r\ny.createModel({\r\n  name: \"User\", // \"name\" is a reserved property for specifying model name\r\n  firstName: \"John\",\r\n  lastName: \"Doe\",\r\n  fullName: function(first, last, privacy) {\r\n    return privacy === \"private\"? first : `{first} {last}`;\r\n  }.require(\"firstName\", \"lastName\", \"Config.privacy\")\r\n});\r\n```\r\n#### Dealing with arrays\r\nIf the dependency is an array of values, the generator (the computing function) would receive an array as parameter. For instance:\r\n```\r\ny.createModel({\r\n  name: \"Model\",\r\n  items: [1,2,3,4],\r\n  newItems: function(items) {\r\n    return items.map(x=>x+1);\r\n  }.require(\"items\")\r\n});\r\ny.get(\"Model\").observe(\"newItems\").subscribe((ls)=>console.log(ls)) // [2,3,4,5]\r\n```\r\n#### Observable vs Iterable\r\nIf you're not familiar with observables, I would recommend viewing some talks about observables versus iterables. Observables and iterables are interchangable while each having its own specialties.\r\nYou can think of observables = iterables + time. It can do everything an iterable can do and also some operations on time domain; however, it's not as good for some operations like random access.\r\nFortunately in Y, you can freely to choose whichever makes more sense for your operation.\r\nThe parameters passed into the generator will be in the form of an array and the after hook will be in the form of observables\r\nThe previous example has the following equivalent counterpart in the form of observables:\r\n```\r\ny.createModel({\r\n  name: \"Model\",\r\n  items: [1,2,3,4],\r\n  newItems: function(items) {\r\n    return items\r\n  }.require(\"items\").map((x)=>x+1)\r\n});\r\ny.get(\"Model\").observe(\"newItems\").subscribe((x)=>console.log(x)) // [2,3,4,5]\r\n```\r\nHowever, there are some operations that can not be done in the form of arrays.\r\nFor example, if you want to debounce for the new items, it could be easily done with observables \r\n```\r\ny.createModel({\r\n  name: \"Model\",\r\n  items: [1,2,3,4],\r\n  newItems: function(items) {\r\n    return items\r\n  }.require(\"items\").map((x)=>x+1).debounce()\r\n});\r\ny.get(\"Model\").observe(\"newItems\").subscribe((x)=>console.log(x)) // [2,3,4,5]\r\n```\r\n\r\n### Observe a property\r\nNo property would be initialized until you observe it. Both model and collection provide with an observe method to observe one or many properties.\r\nFor example, if you want to observe the fullName from the User model\r\n```\r\ny.get(\"User\").observe(\"fullName\").subscribe((name)=>console.log(name))\r\n```\r\nBy doing this, whenever the firstName or lastName is changed, the callback function registered would be called and passed the latest full name as the parameter.\r\nYou can also have a circular reference between models since properties are actually the smallest units in Y (as long as there's no circular references between properties).\r\n```\r\ny.createModel({\r\n  name: \"A\", \r\n  foo: 1,\r\n  bar: function(bar) {\r\n    return bar;\r\n  }.require(\"B.bar\")\r\n});\r\ny.createModel({\r\n  name: \"B\", \r\n  bar: function(foo) {\r\n    return foo;\r\n  }.require(\"A.foo\")\r\n});\r\ny.get(\"A\").observe(\"bar\").subscribe((bar)=>...)\r\n```\r\n### Action\r\nIn flux, there are actions that change some states of your models. It works the same way in Y while it's obvious actions can only change **state properties**\r\nTake the User model as an example, if I want to change the name when user triggers some interaction:\r\n```\r\ny.createModel({\r\n  name: \"User\", // \"name\" is a reserved property for specifying model name\r\n  firstName: \"John\",\r\n  lastName: \"Doe\",\r\n  fullName: function(first, last) {\r\n    return `{first} {last}`;\r\n  }.require(\"firstName\", \"lastName\"),\r\n  actions: { // \"actions\" is a reserved property for specifying all the actions\r\n    changeName: { // \"an action called changeName\" which is an object contains all the states that will be affected by this action\r\n      firstName: function(evt) {\r\n        return evt.firstName;\r\n      },\r\n      lastName: function(evt) {\r\n        return evt.lastName;\r\n      },\r\n    }\r\n  }\r\n});\r\n// Assume you trigger the action inside some action handler in the view\r\nfunction onClick(evt) {\r\n  y.action(\"changeName\")({\r\n    firstName: \"Alice\",\r\n    lastName \"Chen\"\r\n  })\r\n}\r\n```\r\nAction handlers are similar to computed properties. As a result, it can also be specified with dependencies. If you want to specify a default last name for the example above, you can do the following:\r\n```\r\ny.createModel({\r\n  name: \"User\", // \"name\" is a reserved property for specifying model name\r\n  firstName: \"John\",\r\n  lastName: \"Doe\",\r\n  defaultLastName: \"MyLastName\"\r\n  fullName: function(first, last) {\r\n    return `{first} {last}`;\r\n  }.require(\"firstName\", \"lastName\"),\r\n  actions: { // \"actions\" is a reserved property for specifying all the actions\r\n    changeName: { // \"an action called changeName\" which is an object contains all the states that will be affected by this action\r\n      firstName: function(evt) {\r\n        return evt.firstName;\r\n      },\r\n      lastName: function(evt, defaultLN) {\r\n        return evt.lastName? evt.lastName : defaultLN;\r\n      }.require(\"defaultLastName\"),\r\n    }\r\n  }\r\n});\r\n```\r\n\r\n### Model and Collection\r\nSince properties are the actual functioning units in Y, Model and Collection are the same while providing different helper method.\r\nIn all of the examples above, you could also change to\r\n```\r\ny.createCollection({\r\n  ...\r\n})\r\n```\r\nThe only difference is when you call observe on collection, it would assume the observing values are arrays with the same length (it would use the minimum length across all the observed properties)\r\nEx.\r\n```\r\ny.createCollection({\r\n  name: \"MyCollection\",\r\n  foo: [1,2,3],\r\n  bar: [\"one\", \"two\"]\r\n})\r\ny.get(\"MyCollection\").observe(\"foo\",\"bar\").subscribe((x)=>console.log(x)) // [{foo:1, bar:\"one\"},{foo:2, bar:\"two\"}]\r\n```\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}